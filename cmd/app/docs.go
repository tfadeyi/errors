package app

import (
	"bytes"
	"io"
	"os"

	"github.com/spf13/cobra"
	commonoptions "github.com/tfadeyi/errors/cmd/app/options/common"
	docoptions "github.com/tfadeyi/errors/cmd/app/options/docs"
	"github.com/tfadeyi/errors/internal/generate"
	"github.com/tfadeyi/errors/internal/generate/docs"
	"github.com/tfadeyi/errors/internal/generate/manifest"
	"github.com/tfadeyi/errors/internal/logging"
)

func docsCmd(common *commonoptions.Options) *cobra.Command {
	opts := docoptions.New(common)
	cmd := &cobra.Command{
		Use:     "docs",
		Short:   "Documentation",
		Long:    ``,
		Aliases: []string{"doc"},
		PersistentPreRunE: func(cmd *cobra.Command, args []string) error {
			logger := logging.LoggerFromContext(cmd.Context())
			logger = logger.WithName("docs")

			if err := opts.Complete(); err != nil {
				logger.Error(err, "flag argument error")
				return err
			}
			if opts.LogLevel != "" {
				logger = logger.SetLevel(opts.LogLevel)
			}
			cmd.SetContext(logging.ContextWithLogger(cmd.Context(), logger))
			return nil
		},
	}
	opts = opts.Prepare(cmd)
	cmd.AddCommand(docsGenerateCmd(opts))

	return cmd
}

func docsGenerateCmd(opts *docoptions.Options) *cobra.Command {
	var inputReader io.Reader
	cmd := &cobra.Command{
		Use:   "generate",
		Short: "Generate error documentation from an application error manifest",
		Long:  ``,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			logger := logging.LoggerFromContext(cmd.Context())
			logger = logger.WithName("generate")
			if err := opts.Complete(); err != nil {
				return err
			}

			if opts.Source == "-" {
				inputReader = cmd.InOrStdin()
			} else {
				buf, err := os.ReadFile(opts.Source)
				if err != nil {
					return err
				}
				inputReader = bytes.NewReader(buf)
			}

			cmd.SetContext(logging.ContextWithLogger(cmd.Context(), logger))
			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			logger := logging.LoggerFromContext(cmd.Context())

			logger.Info("Generate documentation from manifest", "file", opts.Source)

			generatorOptions := []docs.Option{
				docs.Logger(&logger),
				docs.Output(opts.OutputDirectory),
				docs.Watermark(`[//]: # (Code generated by errctl: https://github.com/tfadeyi/errors.
# DO NOT EDIT.)`),
			}
			if opts.InfoTemplate != "" {
				generatorOptions = append(generatorOptions, docs.CustomManifestInfoTemplate(opts.InfoTemplate))
			}
			if opts.ErrorTemplate != "" {
				generatorOptions = append(generatorOptions, docs.CustomManifestErrorTemplate(opts.ErrorTemplate))
			}

			switch opts.Format {
			case generate.Markdown:
				generatorOptions = append(generatorOptions, docs.Markdown())
			case "html":
				// do nothing
			default:
				generatorOptions = append(generatorOptions, docs.Markdown())
			}

			application, err := manifest.ValidateFromReader(inputReader)
			if err != nil {
				logger.Error(err, "Invalid error manifest file")
				return nil
			}

			gen := docs.New(generatorOptions...)
			if err := gen.GenerateDocumentation(cmd.Context(), application); err != nil {
				logger.Error(err, "Failed to generate error documentation")
				return nil
			}

			logger.Info("Finished generating documentation âœ…")

			return nil
		},
	}
	opts = opts.Prepare(cmd)
	return cmd
}
